/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <fun>
#include <fakemeta>
#include <engine>
#include <cstrike>
#include <hamsandwich>
#include <torreinc>
#include <dhudmessage>
#include <acg>

#define PLUGIN "Spy [TF2]"
#define VERSION "1.0"
#define AUTHOR "CheQ"

#define PASEK 5178
#define PASEK_LAD 4321
#define MAX 20

#define DMG_BULLET (1<<1)

new bool:jest_niewidzialny[MAX+1];
new przez[MAX+1];
new czas[MAX+1]
new bool:is_spy[MAX+1];
new Float:tajmer[MAX+1];

new const nazwa[] = "Piotr";
new const nazwa_kodowa[] = "No nie ?"
new const opis[] = "Moze uruchomic kamuflaz trzymajac maczete, Atak w plecy z maczety zabija natychmiastowo";
new const grawitacja = 10
new const zdrowie = -10;
new const kondycja = 20;
new const inteligencja = 0;
new const wytrzymalosc = 0;
new const przeladowanie = 0;
new const regeneracja = 10

new mapname[32];

public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	cod_register_class(nazwa, opis, grawitacja, zdrowie, kondycja, inteligencja, wytrzymalosc, przeladowanie, regeneracja, nazwa_kodowa);
	
	RegisterHam(Ham_Spawn,"player","Spawn",1);
	RegisterHam(Ham_TakeDamage, "player", "TakeDmg");
	register_event("CurWeapon", "CurWeapon", "be", "1=1");
	
	set_task(0.3, "PokazPasek", _, _, _, "b")
	
	get_mapname(mapname, 31)
}
public cod_class_enabled(id) 
{
	if(equali(mapname, "gg_", 3) || equali(mapname, "aim_", 4) || equali(mapname, "fun_", 4) || equali(mapname, "awp_", 4))
	{
		return COD_CONTINUE;
	}
	else
	{
		acg_drawtext(id, 0.04, 0.69, "Aby uruchomic kamuflaz trzymajac maczete wcisnij USE (Domyslnie E)^n\rPamietaj ze sprint lub zmiana broni wylacza kamuflaz !", 0, 212, 255, 255, 0.0, 2.5, 5.5, 0, TS_NONE, 0, 1, 11)
	}
	//COD_MSG_SKILL_D;
	//show_hudmessage(id, "Aby uruchomic kamuflaz trzymajac maczete wcisnij USE (Domyslnie E)");
	is_spy[id] = true;
	czas[id] = 5;
	
	return COD_CONTINUE
}

public cod_class_disabled(id)
	is_spy[id] = false;

public plugin_precache()
{
	precache_model("models/QTM_Codmod/v_machete.mdl");
	precache_model("models/QTM_Codmod/p_machete.mdl");
	
	//precache_generic("gfx/piotr_efekt.tga")
}

/*public client_putinserver(id)
{
	if (acg_userstatus(id))
	{
		set_task(1.0,"precachetga",id)
	}
}

public precachetga(id)
{
	acg_precachetga(id, "piotr_efekt")
}*/  // for acg [15/06]

public CurWeapon(id)
{
	if(equali(mapname, "gg_", 3) || equali(mapname, "aim_", 4) || equali(mapname, "fun_", 4) || equali(mapname, "awp_", 4))
		return;
		
	new weapon = read_data(2);

	if(is_spy[id] && weapon == CSW_KNIFE)
	{
		set_pev(id, pev_viewmodel2, "models/QTM_Codmod/v_machete.mdl");
		set_pev(id, pev_weaponmodel2, "models/QTM_Codmod/p_machete.mdl");
		/*entity_set_string(id, EV_SZ_viewmodel, "models/QTM_Codmod/v_machete.mdl");
		entity_set_string(id, EV_SZ_weaponmodel, "models/QTM_Codmod/p_machete.mdl");*/
	}
}

public Spawn(id)
{
	if(equali(mapname, "gg_", 3) || equali(mapname, "aim_", 4) || equali(mapname, "fun_", 4) || equali(mapname, "awp_", 4))
		return;
		
	if(is_spy[id])
	{
		przez[id]=240
		remove_task(id + 9823)
		remove_task(id + PASEK)
		jest_niewidzialny[id]=false;
		czas[id] = 5;
		//COD_MSG_SKILL_D;
		//show_hudmessage(id, "Aby uruchomic kamuflaz, wyciagnij maczete i wcisnij USE (Domyslnie E)^nPamietaj ze sprint lub zmiana broni wylacza kamuflaz !");
	}
}
	
public client_PreThink(id)
{
	if(equali(mapname, "gg_", 3) || equali(mapname, "aim_", 4) || equali(mapname, "fun_", 4) || equali(mapname, "awp_", 4))
		return PLUGIN_CONTINUE;
		
	if(!is_user_alive(id) || !is_spy[id])
		return PLUGIN_CONTINUE;
	
	new int = cod_get_user_intelligence(id)
	tajmer[id] = int*0.1
	
	if(czas[id] && pev(id,pev_button) & IN_USE && pev(id, pev_oldbuttons) & IN_USE && jest_niewidzialny[id])
	{
		remove_task(id + 9823)
		remove_task(id+PASEK)
		remove_task(id+PASEK_LAD)
		acg_setviewentityrenderingmode(id, 1, kRenderTransColor, kRenderFxGlowShell, 255, 0, 0, 0)
		//set_user_rendering(id, kRenderFxGlowShell, 0, 0, 0, kRenderTransColor, 255);
		przez[id] = 240;
		client_print(id, print_center, "Wylaczanie Kamuflazu !")
		//acg_removedrawnimage(id, 2, 29)
		
		if(czas[id]<5)
			set_task(3.0-tajmer[id],"LadowaniePaska",id+PASEK_LAD)
	}
	if(czas[id] && !jest_niewidzialny[id] && get_user_weapon(id) == CSW_KNIFE && pev(id,pev_button) & IN_USE && (pev(id, pev_oldbuttons) & IN_USE))
	{
		remove_task(id+PASEK_LAD)
		remove_task(id+PASEK)
		remove_task(id + 9823)
		set_task(0.1,"niewidzialny",id + 9823)
		client_print(id, print_center, "Uruchamianie Kamuflazu !")
	}
	if(get_user_weapon(id) != CSW_KNIFE && jest_niewidzialny[id])
	{
		if(task_exists(id + 9823))
			remove_task(id + 9823)
		
		remove_task(id+PASEK)
		acg_setviewentityrenderingmode(id, 1, kRenderTransColor, kRenderFxGlowShell, 255, 0, 0, 0)
		//set_user_rendering(id, kRenderFxGlowShell, 0, 0, 0, kRenderTransColor, 255);
		przez[id] = 240;
		jest_niewidzialny[id]=false;
		client_print(id, print_center, "Kamuflaz wylaczony poniewaz zmieniles bron !")
		//acg_removedrawnimage(id, 2, 29)
		if(czas[id]<5)
			set_task(2.0-tajmer[id],"LadowaniePaska",id+PASEK_LAD)
	}
		
	return PLUGIN_CONTINUE;
}
public TakeDmg(this, idinflictor, idattacker, Float:damage, damagebits)
{
	if(equali(mapname, "gg_", 3) || equali(mapname, "aim_", 4) || equali(mapname, "fun_", 4) || equali(mapname, "awp_", 4))
		return HAM_IGNORED;
		
	if(!is_user_alive(this) || !is_user_connected(this) || !is_user_connected(idattacker) || get_user_team(this) == get_user_team(idattacker))
		return HAM_IGNORED;
	
	if(!is_spy[idattacker])
		return HAM_IGNORED;
		
	new health = get_user_health(this);
	new weapon = get_user_weapon(idattacker);
	
	if(health < 2)
		return HAM_IGNORED;
	
	if(weapon == CSW_KNIFE && !UTIL_In_FOV(this, idattacker) && UTIL_In_FOV(idattacker, this) && damage > 2.0 && damagebits & DMG_BULLET)
	{
		cs_set_user_armor(this, 0, CS_ARMOR_NONE);
		cod_inflict_damage(idattacker, this, float(get_user_health(this))-damage+10.0, 0.0, idinflictor, damagebits);
	}
	else if(weapon == CSW_KNIFE && UTIL_In_FOV(this, idattacker) && !UTIL_In_FOV(idattacker, this) && damage > 2.0 && damagebits & DMG_BULLET)
		cod_inflict_damage(idattacker, this, 10.0, 0.5, idinflictor, damagebits);
	
	return HAM_IGNORED;
}
public niewidzialny(id)
{
	id-=9823;
	if(przez[id]>0)
	{
		przez[id]-=15;
		acg_setviewentityrenderingmode(id, 1, kRenderTransColor, kRenderFxGlowShell, przez[id], 0, 0, 0)
		//set_user_rendering(id, kRenderFxGlowShell, 0, 0, 0, kRenderTransColor, przez[id]);
		set_task(0.1,"niewidzialny",id + 9823)
	}
	else
	{
		//acg_drawtga(id, "piotr_efekt", 255, 255, 255, 250, 0.0, 0.0, 0, FX_FADE_INTERVAL, 0.0, 0.0, 1.5, -1.0, DRAW_ADDITIVE, 1, 1, 29);
		client_print(id,print_center,"Kamuflaz wlaczony !")
		remove_task(id + 9823)
		jest_niewidzialny[id]=true;
		set_task(1.0,"CzasFun",id+PASEK)
		return PLUGIN_CONTINUE;
	}
	return PLUGIN_CONTINUE;
}
public CzasFun(id)
{
	id-=PASEK;
	
	if(czas[id]!=0)
	{
		czas[id]-=1;
		set_task(1.0,"CzasFun",id+PASEK)
	}
	else
	{
		new int = cod_get_user_intelligence(id)
		tajmer[id] = int*0.1
		acg_setviewentityrenderingmode(id, 1, kRenderTransColor, kRenderFxGlowShell, 255, 0, 0, 0)
		//set_user_rendering(id, kRenderFxGlowShell, 0, 0, 0, kRenderTransColor, 255);
		client_print(id, print_center, "Kamuflaz wylaczony ! Poczekaj na regeneracje")
		//acg_removedrawnimage(id, 2, 29)
		przez[id] = 240;
		jest_niewidzialny[id]=false;
		remove_task(id+PASEK)
		set_task(3.0-tajmer[id],"LadowaniePaska",id+PASEK_LAD)
	}
}
public LadowaniePaska(id)
{
	id-=PASEK_LAD;
	jest_niewidzialny[id]=false;
	if(czas[id]<5)
	{
		new int = cod_get_user_intelligence(id)
		tajmer[id] = int*0.1
		czas[id]++
		set_task(2.0-tajmer[id],"LadowaniePaska",id+PASEK_LAD)
	}
	else
		remove_task(id+PASEK_LAD)
}
public PokazPasek()
{
	if(equali(mapname, "gg_", 3) || equali(mapname, "aim_", 4) || equali(mapname, "fun_", 4) || equali(mapname, "awp_", 4))
		return PLUGIN_CONTINUE;
		
	for(new id=1; id <= MAX; id++)
	{
		if(!is_user_alive(id) || !is_spy[id])
			return PLUGIN_CONTINUE;
	
		if(czas[id]>= 5)
			set_dhudmessage(0, 255, 0, 0.03, 0.6, 0, 0.0, 0.35, 0.0, 0.0);
		else if(czas[id] == 4)	
			set_dhudmessage(50, 200, 0, 0.03, 0.6, 0, 0.0, 0.35, 0.0, 0.0);
		else if(czas[id] == 3)
			set_dhudmessage(100, 150, 0, 0.03, 0.6, 0, 0.0, 0.35, 0.0, 0.0);
		else if(czas[id] == 2)
			set_dhudmessage(150, 100, 0, 0.03, 0.6, 0, 0.0, 0.35, 0.0, 0.0);
		else if(czas[id] == 1)
			set_dhudmessage(200, 50, 0, 0.03, 0.6, 0, 0.0, 0.35, 0.0, 0.0);
		else if(czas[id] == 0)
			set_dhudmessage(255, 0, 0, 0.03, 0.6, 0, 0.0, 0.35, 0.0, 0.0);
		
		show_dhudmessage(id, "Kamuflaz: %d sek.",czas[id])
		return PLUGIN_CONTINUE;
	}
	
	return PLUGIN_CONTINUE;
}	
//Kod wziety CodMod.
stock bool:UTIL_In_FOV(id,target)
{
	if (Find_Angle(id,target,9999.9) > 0.0)
		return true;
	
	return false;
}
stock Float:Find_Angle(Core,Target,Float:dist)
{
	new Float:vec2LOS[2];
	new Float:flDot;
	new Float:CoreOrigin[3];
	new Float:TargetOrigin[3];
	new Float:CoreAngles[3];
	
	pev(Core,pev_origin,CoreOrigin);
	pev(Target,pev_origin,TargetOrigin);
	
	if (get_distance_f(CoreOrigin,TargetOrigin) > dist)
		return 0.0;
	
	pev(Core,pev_angles, CoreAngles);
	
	for ( new i = 0; i < 2; i++ )
		vec2LOS[i] = TargetOrigin[i] - CoreOrigin[i];
	
	new Float:veclength = Vec2DLength(vec2LOS);
	
	//Normalize V2LOS
	if (veclength <= 0.0)
	{
		vec2LOS[0] = 0.0;
		vec2LOS[1] = 0.0;
	}
	else
	{
		new Float:flLen = 1.0 / veclength;
		vec2LOS[0] = vec2LOS[0]*flLen;
		vec2LOS[1] = vec2LOS[1]*flLen;
	}
	
	//Do a makevector to make v_forward right
	engfunc(EngFunc_MakeVectors,CoreAngles);
	
	new Float:v_forward[3];
	new Float:v_forward2D[2];
	get_global_vector(GL_v_forward, v_forward);
	
	v_forward2D[0] = v_forward[0];
	v_forward2D[1] = v_forward[1];
	
	flDot = vec2LOS[0]*v_forward2D[0]+vec2LOS[1]*v_forward2D[1];
	
	if ( flDot > 0.5 )
	{
		return flDot;
	}
	
	return 0.0;
}

stock Float:Vec2DLength( Float:Vec[2] )  
{ 
	return floatsqroot(Vec[0]*Vec[0] + Vec[1]*Vec[1] );
}

