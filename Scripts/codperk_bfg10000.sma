/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <engine>
#include <cstrike>
#include <fakemeta>
#include <hamsandwich>
#include <fakemeta_util>
#include <codmod>

#define MAKE_MATTERY 7045

new const nazwa[] = "BFG10000";
new const opis[] = "Posiadasz bron z 2 wiazkami na nozu, ktora zadaje powazne obrazenia wrogom znajdujacym sie w poblizu";

new bool: ma_perk[33], bool: ma_bron[33];

new Float:idle[33]
new bfg10k_ammo[33]
new bfg_shooting[33];

enum {NONE = 0, SHOOTING, SHOOTED };

new sprite_blast;
new sprite_laser;


public plugin_init()
{
	register_plugin(nazwa, "1.0", "Hleb & Wi'Waldi");
	
	cod_register_perk(nazwa, opis);	
	
	register_forward(FM_CmdStart, "CmdStart")
	register_forward(FM_PlayerPreThink, "PreThink");
	
	RegisterHam(Ham_Item_Deploy, "weapon_knife", "Weapon_Deploy", 1);
	RegisterHam(Ham_Weapon_WeaponIdle, "weapon_knife", "Weapon_WeaponIdle");
	
	register_event("ResetHUD", "ResetHUD", "abe");
	register_event("HLTV", "Nowa_Runda", "a", "1=0", "2=0");
	
	register_touch("bfg10000", "*" , "DotykWiazki");
	
	register_think("bfg10000", "BFGThink");
	
}
public plugin_precache()
{
	sprite_blast = precache_model("sprites/dexplo.spr");
	sprite_laser = precache_model("sprites/dot.spr")
	precache_sound("weapons/bfg_fire.wav");
	precache_model("models/bfg_mattery.mdl");
	precache_model("models/v_bfg10000.mdl");
	precache_model("models/p_bfg10000.mdl");
}

public cod_perk_enabled(id)
{
	ma_perk[id] = true;	
	ma_bron[id] = true;
	bfg10k_ammo[id] = 2;
}
public cod_perk_disabled(id)
{
	ma_perk[id] = false;
	ma_bron[id] = false;
	bfg10k_ammo[id] = 0;
}
public CmdStart(id, uc_handle)
{
	new weapon = get_user_weapon(id);
	
	if(!is_user_alive(id))
		return PLUGIN_CONTINUE;	
		
	if(weapon == 30 && ma_bron[id])
	{
		if(!ma_perk[id])
		return FMRES_IGNORED
		
		if(!bfg10k_ammo[id] && (pev(id, pev_oldbuttons) & IN_ATTACK))
		{
			client_print(id, print_center, "Wykorzystales juz wszystkie wiazki!");
			return PLUGIN_CONTINUE;
		}
		new Button = get_uc(uc_handle, UC_Buttons)
		new OldButton = pev(id, pev_oldbuttons)	
		new ent = fm_find_ent_by_owner(-1, "weapon_p90", id);
		
		if(Button & IN_ATTACK && !(OldButton & IN_ATTACK) && bfg_shooting[id] == NONE)
		{
			Button &= ~IN_ATTACK;
			set_uc(uc_handle, UC_Buttons, Button);
			
			if(!bfg10k_ammo[id] || !idle[id]) 
				return FMRES_IGNORED;
			if(idle[id] && (get_gametime()-idle[id]<=0.7)) 
				return FMRES_IGNORED;
				
			set_pev(id, pev_weaponanim, 4);
			emit_sound(id, CHAN_ITEM, "weapons/bfg_fire.wav", 0.5, ATTN_NORM, 0, PITCH_NORM);
	
			message_begin(MSG_ONE, get_user_msgid("BarTime"), {0, 0, 0}, id)
			write_byte(1)
			write_byte(0)
			message_end()
	
			bfg_shooting[id] = SHOOTING
			set_task(0.8, "MakeMattery", id+MAKE_MATTERY)
			return FMRES_IGNORED
		}
		if(bfg_shooting[id] == SHOOTING && (Button & (IN_USE | IN_ATTACK2 | IN_BACK | IN_FORWARD | IN_CANCEL | IN_JUMP | IN_MOVELEFT | IN_MOVERIGHT | IN_RIGHT)))
		{
			remove_task(id+MAKE_MATTERY)
			message_begin(MSG_ONE, get_user_msgid("BarTime"), {0, 0, 0}, id)
			write_byte(0)
			write_byte(0)
			message_end()
			bfg_shooting[id] = NONE
			emit_sound(id, CHAN_ITEM, "weapons/bfg_fire.wav", 0.5, ATTN_NORM, (1<<5), PITCH_NORM)
			return FMRES_IGNORED
		}
		if(Button & IN_RELOAD)
		{
			Button &= ~IN_RELOAD;
			set_uc(uc_handle, UC_Buttons, Button);
			
			set_pev(id, pev_weaponanim, 0);
			set_pdata_float(id, 83, 0.5, 4);
			if(ent)
				set_pdata_float(ent, 48, 0.5+3.0, 4);
		}
		
		if(ent)
			cs_set_weapon_ammo(ent, -1);
		cs_set_user_bpammo(id, 30, bfg10k_ammo[id]);	
	}
	else if(weapon != 30 && ma_bron[id])
	{
		idle[id] = 0.0;
		if(task_exists(id+MAKE_MATTERY))
		{
			remove_task(id+MAKE_MATTERY)
			message_begin(MSG_ONE, get_user_msgid("BarTime"), {0, 0, 0}, id)
			write_byte(0)
			write_byte(0)
			message_end()
			bfg_shooting[id] = NONE
			emit_sound(id, CHAN_ITEM, "weapons/bfg_fire.wav", 0.5, ATTN_NORM, (1<<5), PITCH_NORM)
			return FMRES_IGNORED
		}
	}
	return FMRES_IGNORED
}
public MakeMattery(id)
{
	id-=MAKE_MATTERY
	
	bfg_shooting[id] = SHOOTED
	bfg10k_ammo[id]--
	
	new Float: Origin[3], Float: vAngle[3], Float: Velocity[3];
	entity_get_vector(id, EV_VEC_v_angle, vAngle);
	entity_get_vector(id, EV_VEC_origin , Origin);
	set_pev(id, pev_weaponanim, 2);
	
	new ent = create_entity("info_target");
		
	entity_set_string(ent, EV_SZ_classname, "bfg10000");
	entity_set_model(ent, "models/bfg_mattery.mdl");
	fm_set_user_rendering(ent, kRenderFxGlowShell, 0, 255, 0, kRenderNormal, 255)
	
	message_begin(MSG_ONE_UNRELIABLE, get_user_msgid("ScreenShake"),_, id);
	write_short(255<<14);
	write_short(2<<12);
	write_short(255<<14);
	message_end();
	
	vAngle[0] *= -1.0;
	
	entity_set_origin(ent, Origin);
	entity_set_vector(ent, EV_VEC_angles, vAngle);
	
	entity_set_int(ent, EV_INT_effects, 2);
	entity_set_int(ent, EV_INT_solid, SOLID_BBOX);
	entity_set_int(ent, EV_INT_movetype, MOVETYPE_FLY);
	entity_set_edict(ent, EV_ENT_owner, id);
	
	VelocityByAim(id, 300 , Velocity);
	entity_set_vector(ent, EV_VEC_velocity ,Velocity);
	entity_set_float(ent, EV_FL_nextthink, halflife_time() + 0.1);
}
public DotykWiazki(ent)
{
	if (!is_valid_ent(ent))
		return PLUGIN_CONTINUE;

	new attacker = entity_get_edict(ent, EV_ENT_owner);
	

	new Float:fOrigin[3];
	entity_get_vector(ent, EV_VEC_origin, fOrigin);	
	
	new iOrigin[3];
	for(new i=0;i<3;i++)
		iOrigin[i] = floatround(fOrigin[i]);
	
	message_begin(MSG_BROADCAST,SVC_TEMPENTITY, iOrigin);
	write_byte(TE_EXPLOSION);
	write_coord(iOrigin[0]);
	write_coord(iOrigin[1]);
	write_coord(iOrigin[2]);
	write_short(sprite_blast);
	write_byte(32); 
	write_byte(20); 
	write_byte(0);
	message_end();

	new entlist[33];
	new numfound = find_sphere_class(ent, "player", 120.0, entlist, 32);
	
	for (new i=0; i<=numfound; i++)
	{		
		new pid = entlist[i];
		
		if (!is_user_alive(pid) || get_user_team(attacker) == get_user_team(pid) || !(pev(ent, pev_flags) & FL_ONGROUND))
			continue;
		cod_inflict_damage(attacker, pid, 40.0, 0.2, ent, (1<<24));
	}
	remove_entity(ent);
	bfg_shooting[attacker] = NONE
	return PLUGIN_CONTINUE
}	
public ResetHUD(id)
{
	bfg10k_ammo[id] = 2;
	bfg_shooting[id] = NONE
}
public client_disconnect(id)
{
	new ent = find_ent_by_class(0, "bfg10000");
	while(ent > 0)
	{
		if(entity_get_edict(id, EV_ENT_owner) == id)
			remove_entity(ent);
		ent = find_ent_by_class(ent, "bfg10000");
	}
}
public BFGThink(ent)
{
	if(entity_get_int(ent, EV_INT_iuser2))
		return PLUGIN_CONTINUE;
	
	
	entity_set_int(ent, EV_INT_iuser1, 1);
	
	new attacker = entity_get_edict(ent, EV_ENT_owner);
	
	new entlist[33];
	new numfound = find_sphere_class(ent, "player", 500.0 , entlist, 32);
		
	for (new i=0; i<numfound; i++)
	{		
		new pid = entlist[i];
		
		if (is_user_alive(pid) && get_user_team(attacker) != get_user_team(pid))
		{
			cod_inflict_damage(attacker, pid, 10.0, 0.1, ent, (1<<24));
			
			new Float:vec1[3]	
			entity_get_vector(ent, EV_VEC_origin, vec1);		
			
			new vec2[3]
			get_user_origin(pid, vec2)
			new iOrigin[3];
			for(new i=0;i<3;i++)
				iOrigin[i] = floatround(vec1[i]);

			message_begin(MSG_BROADCAST,SVC_TEMPENTITY)
			write_byte (0)     //TE_BEAMENTPOINTS 0
			write_coord(iOrigin[0])
			write_coord(iOrigin[1])
			write_coord(iOrigin[2])
			write_coord(vec2[0])
			write_coord(vec2[1])
			write_coord(vec2[2])
			write_short(sprite_laser)
			write_byte(1) // framestart
			write_byte(5) // framerate
			write_byte(2) // life
			write_byte(10) // width
			write_byte(0) // noise
			write_byte(0)     // r, g, b
			write_byte(255)       // r, g, b
			write_byte(0)       // r, g, b
			write_byte(255) // brightness
			write_byte(150) // speed
			message_end()
		}
	}

	entity_set_float(ent, EV_FL_nextthink, halflife_time() + 0.1);
	
	return PLUGIN_CONTINUE;
}
public Weapon_Deploy(ent)
{
	new id = get_pdata_cbase(ent, 41, 4);
	if(ma_bron[id])
	{
		set_pev(id, pev_viewmodel2, "models/v_bfg10000.mdl");
		set_pev(id, pev_weaponmodel2, "models/p_bfg10000.mdl");
	}
	return PLUGIN_CONTINUE;
}
public Weapon_WeaponIdle(ent)
{
	new id = get_pdata_cbase(ent, 41, 4);
	if(get_user_weapon(id) == 30 && ma_bron[id])
	{
		if(!idle[id]) 
			idle[id] = get_gametime();
	}
}
public Nowa_Runda()
{
        new ent = find_ent_by_class(-1, "bfg10000");
        while(ent > 0)
        {
                remove_entity(ent);
                ent = find_ent_by_class(ent, "bfg10000");
        }       
}
